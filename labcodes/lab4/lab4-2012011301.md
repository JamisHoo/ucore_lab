1

```
alloc_proc函数的主要目的是创建一个进程控制块，进程控制块内所表示的信息均未知，设置一个默认的值，比如state设置为PROC_UNINIT，pid设置为-1，cr3设置为boot_cr3以使得这个进程（线程）默认使用内核的共享地址空间。其他变量多设置为NULL或0。


context中保存有指令指针、栈顶指针、栈帧指针、通用寄存器用于保存进程切换的上下文。
tf中保存有通用寄存器、段寄存器、异常号、指令指针、栈指针等，用于保存进入异常处理和返回时上下文。

```

2

```
首先建立一个进程控制块，该进程的父进程指向当前进程，然后分配内核态堆空间，之后复制用户态存储空间，对于复制内核态线程来说，这步实际什么也没做，然后调用copy_thread设置新进程的异常帧，进程切换上下文的指令地址和栈指针，之后调用get_pid获得一个唯一的id给新线程，然后将新进程加入到进程队列中，然后将该线程设置成就绪，最后返回新线程的id。

每个新线程一个唯一的pid，get_pid函数中对此做保证。
```

3

```
有两个进程（或线程，下同）prev和next，当前运行进程是prev，要切换到next，这个切换过程不能被打断，首先先关闭中断响应，然后将表示当前进程的全局变量current更改为next，然后将TSS中栈指针设置为新进程内核栈的栈顶，切换页表（修改CR3寄存器），然后调用switch_to，swtich_to执行完成后就切换到next进程执行了，不会返回，但是prev进程当前执行的状态会被记录在prev->context中（eip是调用switch_to这条指令的下一条指令），下次prev进程被调度到时会恢复eflags寄存器，使能该进程的中断。

下面说switch_to，switch_to有两个参数分别为prev的context和next的context，首先将当前正在运行的进程(prev)的上下文保存在prev->context中，然后加载next->context，此时栈顶指针已经被修改成next的栈顶指针，栈上的函数返回地址也已经被修改，之后执行ret，返回到next上下文中保存的指令所在地址。


初始化了一个idle的内核线程，这个线程实际上是自己初始化自己，在lab4之前，ucore只是执行一系列指令，没有进程（线程）的概念，进入lab4后首先将自己初始化成第一个内核线程。之后又创建了一个内核线程执行init_main函数。

local_intr_save/restore是保存/恢复当前进程中断使能标志，并关闭/使能中断。中断标志保存在eflags寄存器中。


```
